<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Digital Code Vault â€” Email Security (MCQ + Recovery)</title>
<style>
  :root{
    --bg0:#050816;
    --bg1:#070b1d;

    --ink:#EAF1FF;
    --muted:#A9B6D7;

    --panel: rgba(255,255,255,.06);
    --stroke: rgba(255,255,255,.12);

    --cyan:#55D6FF;
    --cyan2:#2C7BFF;

    --good:#2EE59D;
    --bad:#FF5A7A;

    --gold1:#F7D36A;
    --gold2:#B8872B;

    --shadow: 0 18px 70px rgba(0,0,0,.55);
    --r: 18px;
  }

  *{box-sizing:border-box}
  body{
    margin:0; color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    min-height:100vh;
    display:flex; justify-content:center; align-items:center;
    padding:16px;
    background:
      radial-gradient(1100px 650px at 50% 20%, rgba(85,214,255,.22), rgba(85,214,255,0) 55%),
      radial-gradient(900px 550px at 20% 70%, rgba(44,123,255,.18), rgba(44,123,255,0) 60%),
      radial-gradient(900px 550px at 80% 70%, rgba(162,28,255,.14), rgba(162,28,255,0) 60%),
      linear-gradient(180deg, var(--bg0), var(--bg1));
    overflow-x:hidden;
  }

  .wrap{width:min(1120px, 100%);}

  header{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    margin-bottom:12px; flex-wrap:wrap;
  }

  .brand{display:flex; align-items:center; gap:10px;}
  .logo{
    width:44px;height:44px;border-radius:14px;
    background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.55), rgba(85,214,255,.55) 35%, rgba(44,123,255,.75) 70%, rgba(0,0,0,.35));
    box-shadow: 0 12px 30px rgba(85,214,255,.18);
    border:1px solid rgba(255,255,255,.14);
  }
  .title h1{margin:0;font-size:16.5px;letter-spacing:.2px}
  .title p{margin:2px 0 0;color:var(--muted);font-size:12.5px;line-height:1.25}

  .actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .pill{
    display:flex; align-items:center; gap:8px;
    padding:10px 12px;
    border-radius:999px;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    backdrop-filter: blur(8px);
  }
  .pill span{color:var(--muted); font-size:12.5px}
  .pill b{font-size:13px}
  .btn{
    appearance:none; border:0; cursor:pointer;
    padding:10px 12px;
    border-radius:12px;
    color:var(--ink);
    background: rgba(255,255,255,.08);
    border:1px solid rgba(255,255,255,.12);
    box-shadow: 0 10px 26px rgba(0,0,0,.25);
    transition: transform .12s ease, filter .12s ease;
  }
  .btn:hover{transform: translateY(-1px); filter: brightness(1.05)}
  .btn:active{transform: translateY(0)}
  .btn.primary{
    background: linear-gradient(180deg, rgba(85,214,255,.95), rgba(44,123,255,.95));
    border:1px solid rgba(255,255,255,.18);
  }
  .btn.danger{
    background: linear-gradient(180deg, rgba(255,90,122,.95), rgba(225,29,72,.95));
    border:1px solid rgba(255,255,255,.16);
  }

  .grid{
    display:grid;
    grid-template-columns: 1.35fr .85fr;
    gap:14px;
  }
  @media (max-width: 920px){ .grid{grid-template-columns: 1fr;} }

  /* ===== Main board ===== */
  .board{
    border-radius: var(--r);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.12);
    box-shadow: var(--shadow);
    overflow:hidden;
    position:relative;
  }
  .boardInner{padding:14px; position:relative;}

  .starfield{
    position:absolute; inset:0;
    background:
      radial-gradient(2px 2px at 12% 18%, rgba(255,255,255,.6), rgba(255,255,255,0) 60%),
      radial-gradient(2px 2px at 22% 72%, rgba(255,255,255,.55), rgba(255,255,255,0) 60%),
      radial-gradient(2px 2px at 66% 22%, rgba(255,255,255,.5), rgba(255,255,255,0) 60%),
      radial-gradient(2px 2px at 82% 64%, rgba(255,255,255,.55), rgba(255,255,255,0) 60%),
      radial-gradient(2px 2px at 48% 80%, rgba(255,255,255,.45), rgba(255,255,255,0) 60%),
      radial-gradient(2px 2px at 90% 30%, rgba(255,255,255,.35), rgba(255,255,255,0) 60%);
    opacity:.55;
    pointer-events:none;
  }

  .arena{
    border-radius: 18px;
    background:
      radial-gradient(900px 600px at 50% 30%, rgba(85,214,255,.18), rgba(85,214,255,0) 60%),
      linear-gradient(180deg, rgba(7,12,28,.92), rgba(5,8,18,.92));
    border:1px solid rgba(255,255,255,.10);
    padding:16px;
    position:relative;
    overflow:hidden;
  }

  .scanLine{
    position:absolute;
    left:-40%;
    top:0;
    width:40%;
    height:100%;
    background: linear-gradient(90deg, rgba(255,255,255,0), rgba(85,214,255,.20), rgba(255,255,255,0));
    transform: skewX(-16deg);
    animation: scan 4.8s ease-in-out infinite;
    opacity:.55;
    pointer-events:none;
  }
  @keyframes scan{
    0%, 35%{transform: translateX(-60%) skewX(-16deg)}
    70%{transform: translateX(290%) skewX(-16deg)}
    100%{transform: translateX(290%) skewX(-16deg)}
  }

  .topRow{
    display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
    margin-bottom:12px;
  }
  .kicker{
    color:var(--muted);
    font-size:12.5px;
    line-height:1.35;
  }
  .kbd{
    font-size:12px; color:var(--muted);
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
  }

  /* ===== Digital lock board ===== */
  .lockBoard{
    display:grid;
    grid-template-columns: 1.1fr .9fr;
    gap:14px;
    align-items:center;
  }
  @media (max-width: 820px){ .lockBoard{grid-template-columns: 1fr;} }

  .digitsPanel{
    border-radius: 18px;
    background: rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    padding:14px;
    position:relative;
    overflow:hidden;
  }

  .digitsTitle{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; flex-wrap:wrap;
    margin-bottom:10px;
  }
  .digitsTitle b{font-size:13px; letter-spacing:.2px}
  .digitsTitle small{color:var(--muted); font-size:12px}

  .digits{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    align-items:center;
  }
  .digit{
    width:44px; height:52px;
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    font-size:22px;
    font-weight:800;
    letter-spacing:.5px;
    position:relative;
    border:1px solid rgba(255,255,255,.12);
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
    box-shadow: inset 0 0 0 1px rgba(0,0,0,.30);
  }
  .digit .blur{
    width:18px;height:18px;border-radius:50%;
    background: rgba(255,255,255,.30);
    filter: blur(6px);
    opacity:.85;
  }
  .digit.revealed{
    background:
      radial-gradient(140px 60px at 50% 35%, rgba(85,214,255,.18), rgba(85,214,255,0) 60%),
      linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    border-color: rgba(85,214,255,.35);
    box-shadow:
      inset 0 0 0 1px rgba(0,0,0,.35),
      0 0 24px rgba(85,214,255,.18);
  }
  .digit.revealed span{
    color: rgba(234,241,255,.96);
    text-shadow: 0 0 14px rgba(85,214,255,.35);
  }
  .digit.revealPop{ animation: revealPop .35s ease; }
  @keyframes revealPop{
    0%{transform: scale(.96); filter: brightness(.95)}
    60%{transform: scale(1.03); filter: brightness(1.12)}
    100%{transform: scale(1); filter: brightness(1)}
  }

  .progressRow{
    margin-top:12px;
    display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
  }
  .bar{
    width:240px; height:10px; border-radius:999px;
    background: rgba(255,255,255,.10);
    border:1px solid rgba(255,255,255,.10);
    overflow:hidden;
  }
  .bar > i{
    display:block; height:100%; width:0%;
    background: linear-gradient(90deg, rgba(46,229,157,.95), rgba(85,214,255,.95));
    border-radius:999px;
    transition: width .35s ease;
  }
  .hint{color:var(--muted); font-size:12.5px}

  /* ===== Lock + vault illustration (SVG + CSS animation) ===== */
  .vaultStage{
    border-radius: 18px;
    background: rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    padding:14px;
    position:relative;
    overflow:hidden;
    min-height: 270px;
  }
  .vaultStage::before{
    content:"";
    position:absolute; inset:-40% -30% auto -30%;
    height:60%;
    background: radial-gradient(circle at 50% 60%, rgba(247,211,106,.16), rgba(247,211,106,0) 70%);
    pointer-events:none;
  }

  .lockGlow{
    position:absolute;
    width:260px;height:260px;border-radius:50%;
    left:50%; top:45%;
    transform: translate(-50%,-50%);
    background: radial-gradient(circle at 50% 50%, rgba(85,214,255,.35), rgba(85,214,255,0) 68%);
    pointer-events:none;
  }

  .vaultSvg{
    width:100%;
    height:250px;
    display:block;
    filter: drop-shadow(0 18px 26px rgba(0,0,0,.55));
    position:relative;
    z-index:1;
  }

  .unlockPulse{ animation: unlockPulse .55s ease; }
  @keyframes unlockPulse{
    0%{filter: brightness(1)}
    50%{filter: brightness(1.18)}
    100%{filter: brightness(1)}
  }

  .shake{ animation: shake .35s ease; }
  @keyframes shake{
    0%{transform: translateX(0)}
    25%{transform: translateX(-5px)}
    50%{transform: translateX(5px)}
    75%{transform: translateX(-4px)}
    100%{transform: translateX(0)}
  }

  /* vault opening animation using CSS variables */
  .vaultDoorsOpen #doorL{ transform: translateX(-84px); }
  .vaultDoorsOpen #doorR{ transform: translateX(84px); }
  .vaultDoorsOpen #shackle{ transform: translateY(-18px); }
  #doorL, #doorR, #shackle{ transition: transform 1.05s ease; transform-origin:center; }

  .lightBurst{
    position:absolute;
    inset:0;
    background: radial-gradient(circle at 50% 55%, rgba(247,211,106,.28), rgba(247,211,106,0) 60%);
    opacity:0;
    pointer-events:none;
  }
  .vaultDoorsOpen .lightBurst{
    opacity:1;
    transition: opacity .9s ease;
  }

  /* ===== Right panel ===== */
  .side{
    border-radius: var(--r);
    background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.12);
    box-shadow: var(--shadow);
    overflow:hidden;
  }
  .sideInner{padding:14px}
  .sideInner h2{margin:0;font-size:15px}
  .sideInner p{margin:6px 0 0; color:var(--muted); font-size:12.5px; line-height:1.35}
  .stats{
    margin-top:12px;
    display:grid; grid-template-columns: 1fr 1fr;
    gap:10px;
  }
  .stat{
    border-radius: 14px;
    background: rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    padding:10px;
  }
  .stat b{display:block;font-size:16px}
  .stat span{display:block;color:var(--muted);font-size:12px;margin-top:2px}
  .note{
    margin-top:12px;
    border-radius: 14px;
    padding:10px;
    background: rgba(85,214,255,.10);
    border:1px solid rgba(85,214,255,.20);
    font-size:12.5px; line-height:1.35;
  }

  /* ===== Modal ===== */
  .overlay{
    position:fixed; inset:0;
    background: rgba(0,0,0,.58);
    display:none;
    align-items:center; justify-content:center;
    padding:16px;
    z-index:50;
  }
  .overlay.show{display:flex}
  .modal{
    width:min(820px, 100%);
    border-radius: 18px;
    background: linear-gradient(180deg, rgba(20,34,66,.96), rgba(9,12,22,.96));
    border: 1px solid rgba(255,255,255,.12);
    box-shadow: 0 30px 120px rgba(0,0,0,.65);
    overflow:hidden;
    position:relative;
  }
  .modal::before{
    content:"";
    position:absolute; inset:-60% -40% auto -40%;
    height:65%;
    background: radial-gradient(circle at 50% 60%, rgba(247,211,106,.18), rgba(247,211,106,0) 70%);
    pointer-events:none;
  }
  .mHead{
    padding:14px 14px 10px;
    display:flex; justify-content:space-between; align-items:flex-start; gap:10px;
    position:relative;
  }
  .mHead h3{margin:0; font-size:15.5px}
  .mHead small{display:block; color:var(--muted); margin-top:4px}

  .badge{
    display:inline-flex; align-items:center; gap:8px;
    margin-top:8px;
    padding:6px 10px;
    border-radius: 999px;
    font-size:12px;
    border:1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.06);
    color: var(--muted);
  }
  .badge.good{border-color: rgba(46,229,157,.30); background: rgba(46,229,157,.10); color: rgba(234,241,255,.92);}
  .badge.bad{border-color: rgba(255,90,122,.30); background: rgba(255,90,122,.10); color: rgba(234,241,255,.92);}

  .mBody{padding:0 14px 14px; position:relative;}
  .qText{
    margin:10px 0 12px;
    font-size:15px;
    line-height:1.45;
  }
  .choices{display:grid; gap:10px;}
  .choice{
    width:100%;
    text-align:left;
    padding:12px 12px;
    border-radius:14px;
    background: rgba(255,255,255,.06);
    border:1px solid rgba(255,255,255,.12);
    color:var(--ink);
    cursor:pointer;
    transition: transform .10s ease, background .12s ease, border-color .12s ease;
  }
  .choice:hover{transform: translateY(-1px); background: rgba(255,255,255,.08)}
  .choice:active{transform: translateY(0px)}
  .choice[disabled]{cursor:not-allowed; opacity:.80}
  .choice.good{
    border-color: rgba(46,229,157,.45);
    background: rgba(46,229,157,.12);
  }
  .choice.bad{
    border-color: rgba(255,90,122,.45);
    background: rgba(255,90,122,.10);
  }
  .mFoot{
    display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;
    padding:12px 14px 14px;
    border-top:1px solid rgba(255,255,255,.08);
    background: rgba(0,0,0,.12);
    position:relative;
  }

  .toast{
    position:fixed;
    left:50%; top:18px; transform:translateX(-50%);
    padding:10px 12px;
    border-radius: 999px;
    background: rgba(0,0,0,.55);
    border: 1px solid rgba(255,255,255,.15);
    color: var(--ink);
    font-size: 12.5px;
    display:none;
    z-index:80;
    backdrop-filter: blur(10px);
  }
  .toast.show{display:block; animation: pop .18s ease}
  @keyframes pop{from{transform:translateX(-50%) scale(.95); opacity:.6} to{transform:translateX(-50%) scale(1); opacity:1}}

  /* Confetti */
  .confetti{
    position:absolute; inset:0;
    pointer-events:none;
    opacity:0;
  }
  .confetti.show{opacity:1; animation: fadeOut 1.2s ease forwards}
  @keyframes fadeOut{0%{opacity:1} 100%{opacity:0}}

  /* Final banner */
  .finalBanner{
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%,-50%);
    padding:12px 14px;
    border-radius: 16px;
    background: rgba(0,0,0,.45);
    border:1px solid rgba(255,255,255,.16);
    backdrop-filter: blur(10px);
    box-shadow: 0 18px 60px rgba(0,0,0,.55);
    font-weight:800;
    letter-spacing:.3px;
    display:none;
    z-index:5;
    text-align:center;
    width:min(520px, 92%);
  }
  .finalBanner.show{display:block; animation: pop .18s ease}
  .finalBanner small{display:block; margin-top:6px; font-weight:600; color:var(--muted); font-size:12.5px}
</style>
</head>

<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div class="title">
        <h1>Digital Code Vault â€” Email Security</h1>
        <p>Answer MCQs to reveal digits. If wrong, you get one recovery question. Reveal all digits to unlock the vault.</p>
      </div>
    </div>

    <div class="actions">
      <div class="pill"><span>Digits</span><b id="done">0</b><span>/</span><b id="total">10</b></div>
      <div class="pill"><span>Score</span><b id="score">0</b></div>
      <button class="btn" id="muteBtn" type="button">ðŸ”Š Sound</button>
      <button class="btn primary" id="startBtn" type="button">Start</button>
      <button class="btn danger" id="resetBtn" type="button">Reset</button>
    </div>
  </header>

  <div class="grid">
    <section class="board">
      <div class="starfield"></div>
      <div class="boardInner">
        <div class="arena" id="arena">
          <div class="scanLine"></div>

          <div class="topRow">
            <div class="kicker" id="kicker">
              <b>Rule:</b> Each digit needs one correct answer. If you answer wrong, you get <b>one</b> recovery question (True/False).
            </div>
            <span class="kbd" id="nextHint">Press Start</span>
          </div>

          <div class="lockBoard">
            <div class="digitsPanel">
              <div class="digitsTitle">
                <b>10-Digit Lock Code</b>
                <small id="progressText">Digits Verified: 0 / 10</small>
              </div>

              <div class="digits" id="digits"></div>

              <div class="progressRow">
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;">
                  <div class="bar"><i id="barFill"></i></div>
                  <span class="hint" id="barText">0% verified</span>
                </div>
                <span class="hint" id="streakText">Streak: 0</span>
              </div>
            </div>

            <div class="vaultStage" id="vaultStage">
              <div class="lockGlow" id="lockGlow"></div>
              <div class="lightBurst"></div>

              <!-- Vault + Lock SVG -->
              <svg class="vaultSvg" viewBox="0 0 640 300" aria-label="Vault and lock illustration">
                <defs>
                  <linearGradient id="steel" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0" stop-color="#E6EDF8"/>
                    <stop offset=".35" stop-color="#9AA6B8"/>
                    <stop offset="1" stop-color="#2B3445"/>
                  </linearGradient>
                  <linearGradient id="door" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="0" stop-color="#1B2640"/>
                    <stop offset=".55" stop-color="#101a2f"/>
                    <stop offset="1" stop-color="#0a1020"/>
                  </linearGradient>
                  <radialGradient id="vaultGlow" cx="50%" cy="55%" r="65%">
                    <stop offset="0" stop-color="rgba(85,214,255,.35)"/>
                    <stop offset="70%" stop-color="rgba(85,214,255,.08)"/>
                    <stop offset="100%" stop-color="rgba(85,214,255,0)"/>
                  </radialGradient>
                </defs>

                <!-- Background ring -->
                <circle cx="320" cy="150" r="120" fill="url(#vaultGlow)" opacity=".9"/>

                <!-- Vault frame -->
                <rect x="170" y="78" width="300" height="170" rx="22" fill="rgba(255,255,255,.05)" stroke="rgba(255,255,255,.12)"/>
                <rect x="188" y="94" width="264" height="138" rx="18" fill="rgba(0,0,0,.22)" stroke="rgba(255,255,255,.10)"/>

                <!-- Doors (move apart on open) -->
                <g id="doorL">
                  <rect x="192" y="98" width="132" height="130" rx="14" fill="url(#door)" stroke="rgba(255,255,255,.10)"/>
                  <circle cx="258" cy="163" r="18" fill="rgba(0,0,0,.30)" stroke="rgba(255,255,255,.10)"/>
                  <circle cx="258" cy="163" r="6" fill="rgba(85,214,255,.45)"/>
                </g>

                <g id="doorR">
                  <rect x="316" y="98" width="132" height="130" rx="14" fill="url(#door)" stroke="rgba(255,255,255,.10)"/>
                  <circle cx="382" cy="163" r="18" fill="rgba(0,0,0,.30)" stroke="rgba(255,255,255,.10)"/>
                  <circle cx="382" cy="163" r="6" fill="rgba(85,214,255,.45)"/>
                </g>

                <!-- Lock in front -->
                <g transform="translate(0,0)">
                  <!-- outer glow circle -->
                  <circle cx="320" cy="170" r="82" fill="rgba(85,214,255,.10)" stroke="rgba(85,214,255,.14)"/>

                  <!-- shackle (moves up on open) -->
                  <path id="shackle" d="M280 168v-32c0-24 16-40 40-40s40 16 40 40v32"
                        fill="none" stroke="url(#steel)" stroke-width="12" stroke-linecap="round"/>

                  <!-- body -->
                  <path d="M258 168h124c12 0 22 10 22 22v48c0 26-20 46-46 46h-76c-26 0-46-20-46-46v-48c0-12 10-22 22-22z"
                        fill="url(#door)" stroke="rgba(255,255,255,.14)" stroke-width="2"/>

                  <!-- keyhole plate -->
                  <circle cx="320" cy="214" r="34" fill="rgba(0,0,0,.25)" stroke="rgba(85,214,255,.18)" stroke-width="2"/>
                  <path d="M320 200c-8 0-14 6-14 14 0 5 3 10 8 12v20c0 3 2 5 6 5s6-2 6-5v-20c5-2 8-7 8-12 0-8-6-14-14-14z"
                        fill="rgba(85,214,255,.85)"/>
                </g>

                <!-- Small bolts -->
                <circle cx="188" cy="94" r="4" fill="rgba(255,255,255,.25)"/>
                <circle cx="452" cy="94" r="4" fill="rgba(255,255,255,.25)"/>
                <circle cx="188" cy="232" r="4" fill="rgba(255,255,255,.25)"/>
                <circle cx="452" cy="232" r="4" fill="rgba(255,255,255,.25)"/>
              </svg>

              <canvas class="confetti" id="confetti"></canvas>
              <div class="finalBanner" id="finalBanner">
                ACCESS GRANTED â€” VAULT OPENED
                <small id="finalSub">Code verified successfully.</small>
              </div>
            </div>
          </div>

        </div>
      </div>
    </section>

    <aside class="side">
      <div class="sideInner">
        <h2>Session Summary</h2>
        <p>Logs are clean: digit-by-digit progress, recovery usage, and time-to-complete.</p>

        <div class="stats">
          <div class="stat"><b id="acc">0%</b><span>Accuracy</span></div>
          <div class="stat"><b id="time">0s</b><span>Time</span></div>
          <div class="stat"><b id="correct">0</b><span>Correct</span></div>
          <div class="stat"><b id="wrong">0</b><span>Wrong</span></div>
        </div>

        <div class="note" id="note">
          <b>Status:</b> Press <b>Start</b> to begin. You will answer one MCQ per digit.
        </div>
      </div>
    </aside>
  </div>
</div>

<!-- Modal -->
<div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Question modal">
  <div class="modal" id="modal">
    <div class="mHead">
      <div>
        <h3 id="mTitle">Digit 1</h3>
        <small id="mSub">One attempt â€¢ Recovery appears only if wrong</small>
        <div id="modeBadge" class="badge">MAIN QUESTION</div>
      </div>
      <button class="btn" id="closeBtn" type="button">Close</button>
    </div>

    <div class="mBody">
      <div class="qText" id="qText"></div>
      <div class="choices" id="choices"></div>
    </div>

    <div class="mFoot">
      <div id="feedback" style="color:var(--muted)">Choose the best answer.</div>
      <button class="btn primary" id="nextBtn" type="button" disabled>Continue</button>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* ============================================================
   Email Security MCQs (built from the uploaded chapter content)
   Key verified facts included:
   - Spam warning signs (unknown sender, misspellings like p0rn, offers too good, mismatch subject/content, urgent offer end date, request to forward, virus warning, attachments incl .exe)
   - Enigmail + GnuPG add OpenPGP to Thunderbird
   - GnuPG protects only content and attachments you encrypt
   - Never encrypted: Subject line, sender email, recipients email, real names
   - Inline PGP vs PGP/MIME: inline leaves attachment filenames unencrypted; chapter advises always use PGP/MIME
============================================================ */

const QUESTION_BANK = [
  // SPAM / Scam section
  {
    q: "Which is a warning sign of spam mentioned in the chapter?",
    choices: [
      "You donâ€™t know the sender",
      "The email is always digitally signed",
      "The email only contains plain text",
      "The email is sent from your own domain"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: Unknown sender is listed as a spam warning sign.",
    feedbackWrong: "Incorrect: The chapter lists unknown sender as a spam warning sign.",
    recovery: { q: "True/False: A message from an unknown sender can be a spam warning sign.", answerIndex: 0 }
  },
  {
    q: "The chapter notes spam may use misspellings like â€œp0rnâ€ mainly to:",
    choices: [
      "Improve grammar",
      "Fool spam filters",
      "Encrypt the subject line",
      "Increase attachment size"
    ],
    answerIndex: 1,
    feedbackCorrect: "Correct: Misspellings are used to fool spam filters.",
    feedbackWrong: "Incorrect: The purpose is to fool spam filters.",
    recovery: { q: "True/False: Misspellings like â€œp0rnâ€ can be used to fool spam filters.", answerIndex: 0 }
  },
  {
    q: "Which spam sign is explicitly mentioned in the chapter?",
    choices: [
      "The subject line and contents do not match",
      "The email uses a strong passphrase",
      "The email is always short",
      "The email contains no links"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: Subject line/content mismatch is listed as a warning sign.",
    feedbackWrong: "Incorrect: The chapter lists subject/content mismatch as a warning sign.",
    recovery: { q: "True/False: A mismatch between subject and content is a spam warning sign.", answerIndex: 0 }
  },
  {
    q: "The chapter lists which of these as a spam warning sign?",
    choices: [
      "An urgent offer end date (e.g., â€œBuy now and get 50% offâ€)",
      "A verified invoice number",
      "A personal greeting from your known contact",
      "A message with no subject line"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: Urgent offer end dates are listed as a spam warning sign.",
    feedbackWrong: "Incorrect: Urgent offer end dates are listed as spam warning signs.",
    recovery: { q: "True/False: Spam may include an urgent offer end date.", answerIndex: 0 }
  },
  {
    q: "A spam email may contain a request to:",
    choices: [
      "Forward the email to multiple people (sometimes offering money)",
      "Verify the GnuPG fingerprint",
      "Create a revocation certificate immediately",
      "Disable PGP/MIME permanently"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter mentions requests to forward emails to multiple people.",
    feedbackWrong: "Incorrect: The chapter mentions requests to forward emails to multiple people.",
    recovery: { q: "True/False: Spam may request you to forward an email to many people.", answerIndex: 0 }
  },
  {
    q: "The chapter notes spam may include attachments that could include:",
    choices: [
      ".exe",
      ".txt only",
      ".jpg only",
      ".pdf only"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: .exe is explicitly mentioned as a possible risky attachment type.",
    feedbackWrong: "Incorrect: The chapter explicitly mentions .exe as a possible attachment type.",
    recovery: { q: "True/False: Spam emails may contain attachments including .exe files.", answerIndex: 0 }
  },

  // Thunderbird + OpenPGP section
  {
    q: "According to the chapter, Enigmail and GnuPG improve security by adding support for:",
    choices: [
      "OpenPGP end-to-end encryption in Thunderbird",
      "Automatic spam deletion on the server",
      "Faster internet speed",
      "Unlimited email storage"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: They add OpenPGP end-to-end encryption support to Thunderbird.",
    feedbackWrong: "Incorrect: The chapter says Enigmail + GnuPG add OpenPGP support to Thunderbird.",
    recovery: { q: "True/False: Enigmail and GnuPG add OpenPGP end-to-end encryption support to Thunderbird.", answerIndex: 0 }
  },
  {
    q: "The chapter states GnuPG only protects the:",
    choices: [
      "Subject line and sender address",
      "Content of email and attachments you encrypt",
      "Network routing headers",
      "Time stamps stored by mail servers"
    ],
    answerIndex: 1,
    feedbackCorrect: "Correct: GnuPG protects the content and the attachments you encrypt.",
    feedbackWrong: "Incorrect: GnuPG protects the content and the attachments you encrypt.",
    recovery: { q: "True/False: GnuPG only protects the content of email and attachments you encrypt.", answerIndex: 0 }
  },
  {
    q: "Which information is never encrypted (as listed in the chapter)?",
    choices: [
      "The Subject line",
      "The encrypted body content",
      "Attachments you encrypt",
      "A copy encrypted to your public key in Sent mail"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter lists the Subject line as never encrypted.",
    feedbackWrong: "Incorrect: The chapter lists the Subject line as never encrypted.",
    recovery: { q: "True/False: The Subject line is never encrypted according to the chapter.", answerIndex: 0 }
  },
  {
    q: "Which information is never encrypted (as listed in the chapter)?",
    choices: [
      "Recipientsâ€™ email addresses",
      "Encrypted attachments",
      "Encrypted message content",
      "The passphrase itself"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter lists recipientsâ€™ email addresses as never encrypted.",
    feedbackWrong: "Incorrect: The chapter lists recipientsâ€™ email addresses as never encrypted.",
    recovery: { q: "True/False: Recipientsâ€™ email addresses are never encrypted, as per the chapter.", answerIndex: 0 }
  },
  {
    q: "Which information is never encrypted (as listed in the chapter)?",
    choices: [
      "The sender's email address",
      "The encrypted message body",
      "The OpenPGP-encrypted attachment content",
      "The local Sent mail copy"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter lists the sender's email address as never encrypted.",
    feedbackWrong: "Incorrect: The chapter lists the sender's email address as never encrypted.",
    recovery: { q: "True/False: The senderâ€™s email address is never encrypted according to the chapter.", answerIndex: 0 }
  },
  {
    q: "The chapter also notes that real names associated with addresses are:",
    choices: [
      "Always encrypted",
      "Never encrypted",
      "Encrypted only in POP accounts",
      "Encrypted only with Inline PGP"
    ],
    answerIndex: 1,
    feedbackCorrect: "Correct: The chapter lists associated real names as never encrypted.",
    feedbackWrong: "Incorrect: The chapter lists associated real names as never encrypted.",
    recovery: { q: "True/False: Real names associated with sender/recipient addresses are never encrypted (chapter).", answerIndex: 0 }
  },

  // Inline PGP vs PGP/MIME section
  {
    q: "If Enigmail is configured to use Inline PGP instead of PGP/MIME, the chapter warns that:",
    choices: [
      "File names of attachments remain unencrypted",
      "The subject line becomes encrypted automatically",
      "Recipientsâ€™ addresses become encrypted",
      "GnuPG stops working completely"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: Inline PGP leaves attachment file names unencrypted.",
    feedbackWrong: "Incorrect: Inline PGP leaves attachment file names unencrypted.",
    recovery: { q: "True/False: Inline PGP can leave attachment file names unencrypted.", answerIndex: 0 }
  },
  {
    q: "The chapter recommends you should always:",
    choices: [
      "Use PGP/MIME",
      "Disable encryption on Sent mail",
      "Use Inline PGP for attachments",
      "Put sensitive data in the subject line"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter explicitly advises always use PGP/MIME.",
    feedbackWrong: "Incorrect: The chapter explicitly advises always use PGP/MIME.",
    recovery: { q: "True/False: The chapter advises always using PGP/MIME.", answerIndex: 0 }
  },
  {
    q: "Because some metadata is never encrypted, the chapter says it is important to:",
    choices: [
      "Choose subject lines carefully",
      "Ignore subject lines completely",
      "Always include your real name in the email account",
      "Send attachments without encryption"
    ],
    answerIndex: 0,
    feedbackCorrect: "Correct: The chapter highlights careful subject line choice.",
    feedbackWrong: "Incorrect: The chapter says choose subject lines carefully.",
    recovery: { q: "True/False: The chapter suggests choosing subject lines carefully since some info is never encrypted.", answerIndex: 0 }
  }
];

/* ============================================================
   Game settings
============================================================ */
const DIGITS_TOTAL = 10;
const SCORE_MAIN_CORRECT = 10;
const SCORE_RECOVERY_CORRECT = 5;

let state = {
  started: false,
  codeDigits: [],
  revealedCount: 0,

  score: 0,
  correct: 0,
  wrong: 0,

  streak: 0,

  currentQuestion: null, // {mode:'main'|'recovery', digitIndex, qObj, mainAnsweredWrong:boolean}
  muted: false,

  usedQ: [],
  startTime: Date.now()
};

/* ============================================================
   Sound (no external files)
============================================================ */
function beep(type){
  if(state.muted) return;
  const ctx = beep.ctx || (beep.ctx = new (window.AudioContext || window.webkitAudioContext)());
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = "sine";
  const now = ctx.currentTime;

  const presets = {
    click: [420, 0.035],
    good:  [720, 0.085],
    bad:   [170, 0.11],
    win:   [540, 0.14]
  };
  const [freq, dur] = presets[type] || presets.click;

  o.frequency.setValueAtTime(freq, now);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.15, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now + dur);

  o.connect(g); g.connect(ctx.destination);
  o.start(now);
  o.stop(now + dur + 0.02);
}

/* ============================================================
   DOM helpers
============================================================ */
const el = (id)=>document.getElementById(id);
const overlay = el("overlay");
const qText = el("qText");
const choicesEl = el("choices");
const mTitle = el("mTitle");
const mSub = el("mSub");
const feedbackEl = el("feedback");
const nextBtn = el("nextBtn");
const closeBtn = el("closeBtn");
const toast = el("toast");
const modeBadge = el("modeBadge");

function showToast(msg){
  toast.textContent = msg;
  toast.classList.add("show");
  setTimeout(()=>toast.classList.remove("show"), 900);
}

function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function formatTime(sec){
  sec = Math.max(0, Math.floor(sec));
  if(sec < 60) return sec + "s";
  const m = Math.floor(sec/60), s = sec%60;
  return `${m}m ${String(s).padStart(2,"0")}s`;
}

/* ============================================================
   Question selection (avoid repetition until needed)
============================================================ */
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

function resetQuestionDeck(){
  state.usedQ = shuffle([...Array(QUESTION_BANK.length).keys()]);
}

function nextMainQuestion(){
  if(state.usedQ.length === 0) resetQuestionDeck();
  const idx = state.usedQ.pop();
  return QUESTION_BANK[idx];
}

/* ============================================================
   Digits UI
============================================================ */
function renderDigits(){
  const box = el("digits");
  box.innerHTML = "";

  for(let i=0;i<DIGITS_TOTAL;i++){
    const d = document.createElement("div");
    d.className = "digit" + (i < state.revealedCount ? " revealed" : "");
    if(i < state.revealedCount){
      d.innerHTML = `<span>${state.codeDigits[i]}</span>`;
    }else{
      d.innerHTML = `<div class="blur"></div>`;
    }
    box.appendChild(d);
  }
}

function popDigit(i){
  const digitEl = el("digits").children[i];
  if(!digitEl) return;
  digitEl.classList.add("revealPop");
  setTimeout(()=>digitEl.classList.remove("revealPop"), 420);
}

/* ============================================================
   HUD
============================================================ */
function updateHUD(){
  el("done").textContent = String(state.revealedCount);
  el("total").textContent = String(DIGITS_TOTAL);
  el("score").textContent = String(state.score);

  const attempted = state.correct + state.wrong;
  const acc = attempted ? Math.round((state.correct/attempted)*100) : 0;
  el("acc").textContent = acc + "%";
  el("correct").textContent = String(state.correct);
  el("wrong").textContent = String(state.wrong);

  const sec = (Date.now() - state.startTime)/1000;
  el("time").textContent = formatTime(sec);

  el("progressText").textContent = `Digits Verified: ${state.revealedCount} / ${DIGITS_TOTAL}`;
  el("streakText").textContent = `Streak: ${state.streak}`;

  const pct = Math.round((state.revealedCount / DIGITS_TOTAL) * 100);
  el("barFill").style.width = pct + "%";
  el("barText").textContent = `${pct}% verified`;
}
setInterval(updateHUD, 500);

/* ============================================================
   Modal
============================================================ */
function openModal(mode, digitIndex, qObj){
  state.currentQuestion = { mode, digitIndex, qObj };

  mTitle.textContent = `Digit ${digitIndex + 1}`;
  if(mode === "main"){
    mSub.textContent = "Main question â€¢ One attempt";
    modeBadge.textContent = "MAIN QUESTION";
    modeBadge.className = "badge";
    feedbackEl.textContent = "Choose the best answer.";
  }else{
    mSub.textContent = "Recovery question â€¢ One attempt";
    modeBadge.textContent = "RECOVERY";
    modeBadge.className = "badge bad";
    feedbackEl.textContent = "Answer to recover the digit.";
  }

  nextBtn.disabled = true;
  choicesEl.innerHTML = "";

  if(mode === "main"){
    qText.textContent = qObj.q;
    qObj.choices.forEach((ch, i)=>{
      const b = document.createElement("button");
      b.className = "choice";
      b.type = "button";
      b.textContent = ch;
      b.addEventListener("click", ()=> answerMain(i));
      choicesEl.appendChild(b);
    });
  }else{
    qText.textContent = qObj.recovery.q;
    const opts = ["True","False"];
    opts.forEach((ch, i)=>{
      const b = document.createElement("button");
      b.className = "choice";
      b.type = "button";
      b.textContent = ch;
      b.addEventListener("click", ()=> answerRecovery(i));
      choicesEl.appendChild(b);
    });
  }

  overlay.classList.add("show");
  beep("click");
}

function closeModal(){
  overlay.classList.remove("show");
}

closeBtn.addEventListener("click", ()=>{beep("click"); closeModal();});
overlay.addEventListener("click", (e)=>{
  if(e.target === overlay){beep("click"); closeModal();}
});

nextBtn.addEventListener("click", ()=>{
  beep("click");
  closeModal();

  // Continue automatically if not finished
  if(state.revealedCount < DIGITS_TOTAL){
    // Small delay so the learner sees the digit reveal
    setTimeout(()=> askNextDigit(), 260);
  }else{
    // Completed already â€” do nothing; animation handles.
  }
});

function disableChoices(){
  [...choicesEl.querySelectorAll(".choice")].forEach(x=>x.disabled = true);
}

/* ============================================================
   Answer handling
============================================================ */
function answerMain(chosenIndex){
  const { digitIndex, qObj } = state.currentQuestion;

  disableChoices();

  const correct = chosenIndex === qObj.answerIndex;
  const btns = [...choicesEl.querySelectorAll(".choice")];

  btns.forEach((b, i)=>{
    if(i === qObj.answerIndex) b.classList.add("good");
    if(i === chosenIndex && !correct) b.classList.add("bad");
  });

  if(correct){
    state.score += SCORE_MAIN_CORRECT;
    state.correct += 1;
    state.streak += 1;
    feedbackEl.textContent = qObj.feedbackCorrect || "Correct.";
    modeBadge.className = "badge good";
    beep("good");
    revealDigit(digitIndex, true);
    nextBtn.disabled = false;
  }else{
    state.wrong += 1;
    state.streak = 0;
    feedbackEl.textContent = qObj.feedbackWrong || "Wrong. Recovery question will appear.";
    modeBadge.className = "badge bad";
    beep("bad");

    // After brief pause show recovery
    setTimeout(()=>{
      openModal("recovery", digitIndex, qObj);
    }, 650);

    // Keep next disabled for now; recovery modal will manage it.
    nextBtn.disabled = true;
  }
}

function answerRecovery(chosenIndex){
  const { digitIndex, qObj } = state.currentQuestion;
  disableChoices();

  const correct = chosenIndex === qObj.recovery.answerIndex;
  const btns = [...choicesEl.querySelectorAll(".choice")];
  btns.forEach((b, i)=>{
    if(i === qObj.recovery.answerIndex) b.classList.add("good");
    if(i === chosenIndex && !correct) b.classList.add("bad");
  });

  if(correct){
    state.score += SCORE_RECOVERY_CORRECT;
    state.correct += 1; // counts as correct for analytics
    feedbackEl.textContent = "Recovered â€” digit verified.";
    modeBadge.className = "badge good";
    beep("good");
    revealDigit(digitIndex, false);
  }else{
    state.wrong += 1;
    feedbackEl.textContent = "Recovery failed â€” digit remains locked.";
    modeBadge.className = "badge bad";
    beep("bad");
    // Still move on to next digit attempt (same digit remains locked, but we advance)
    // In this design, each digit is tied to one attempt cycle. To keep it fair,
    // we do NOT retry the same digit; we proceed but the digit stays blurred.
    // However, to ensure completion is possible, we allow extra questions after 10 attempts.
  }

  nextBtn.disabled = false;
}

/* ============================================================
   Digit progression model (practical and MOOC-safe)
   - Target is 10 revealed digits.
   - Each "round" is tied to revealing the next unrevealed digit.
   - If recovery fails, we simply do NOT increment revealedCount.
   - Then we continue asking new questions until all 10 digits are revealed.
============================================================ */
function revealDigit(digitIndex, fromMain){
  // Reveal the next unrevealed digit (digitIndex should match revealedCount)
  if(digitIndex !== state.revealedCount) return;

  state.revealedCount += 1;
  renderDigits();
  popDigit(digitIndex);

  // Visual pulse
  const arena = el("arena");
  arena.classList.remove("unlockPulse");
  void arena.offsetWidth;
  arena.classList.add("unlockPulse");

  // Confetti micro burst
  fireConfetti(false);

  showToast(fromMain ? "Digit revealed!" : "Digit recovered!");
  el("nextHint").textContent = "Next digit unlocked";
  el("note").innerHTML = `<b>Status:</b> Digit ${state.revealedCount} verified. Continue to unlock the vault.`;

  if(state.revealedCount >= DIGITS_TOTAL){
    finishVault();
  }
}

/* ============================================================
   Game loop
============================================================ */
function askNextDigit(){
  if(!state.started) return;

  if(state.revealedCount >= DIGITS_TOTAL){
    finishVault();
    return;
  }

  const digitIndex = state.revealedCount;
  const qObj = nextMainQuestion();
  openModal("main", digitIndex, qObj);

  el("nextHint").textContent = `Attempt Digit ${digitIndex + 1}`;
}

function startGame(){
  if(state.started) return;
  state.started = true;
  state.startTime = Date.now();
  el("startBtn").disabled = true;
  el("nextHint").textContent = "Attempt Digit 1";
  el("note").innerHTML = "<b>Status:</b> Game started. Answer MCQs to reveal digits.";
  askNextDigit();
}

function resetGame(){
  state.started = false;
  state.codeDigits = Array.from({length: DIGITS_TOTAL}, ()=> Math.floor(Math.random()*10));
  state.revealedCount = 0;

  state.score = 0;
  state.correct = 0;
  state.wrong = 0;
  state.streak = 0;

  state.currentQuestion = null;
  state.startTime = Date.now();

  resetQuestionDeck();
  renderDigits();
  updateHUD();

  // Reset visuals
  el("vaultStage").classList.remove("vaultDoorsOpen");
  el("finalBanner").classList.remove("show");
  el("finalSub").textContent = "Code verified successfully.";
  el("startBtn").disabled = false;
  el("nextHint").textContent = "Press Start";
  el("note").innerHTML = "<b>Status:</b> Press <b>Start</b> to begin. You will answer one MCQ per digit.";

  showToast("Reset done.");
}

/* ============================================================
   Finish animation (lock opens + vault opens)
============================================================ */
function finishVault(){
  // Prevent multiple triggers
  if(el("vaultStage").classList.contains("vaultDoorsOpen")) return;

  closeModal();

  // Big confetti + animation
  const stage = el("vaultStage");
  stage.classList.add("vaultDoorsOpen");
  fireConfetti(true);
  beep("win");

  el("finalBanner").classList.add("show");
  el("finalSub").textContent = "All 10 digits verified from Email Security concepts.";

  el("note").innerHTML = "<b>Result:</b> Access granted. Vault opened successfully.";
  el("nextHint").textContent = "Vault opened";
}

/* ============================================================
   Confetti
============================================================ */
const confettiCanvas = el("confetti");
const ctx2 = confettiCanvas.getContext("2d");
let confettiParticles = [];

function resizeConfettiCanvas(){
  const arena = el("vaultStage");
  const r = arena.getBoundingClientRect();
  confettiCanvas.width = Math.floor(r.width * devicePixelRatio);
  confettiCanvas.height = Math.floor(r.height * devicePixelRatio);
  confettiCanvas.style.width = r.width + "px";
  confettiCanvas.style.height = r.height + "px";
}
window.addEventListener("resize", resizeConfettiCanvas);

function fireConfetti(big){
  resizeConfettiCanvas();
  confettiCanvas.classList.add("show");
  setTimeout(()=>confettiCanvas.classList.remove("show"), 1200);

  const w = confettiCanvas.width, h = confettiCanvas.height;
  const count = big ? 200 : 70;

  for(let i=0;i<count;i++){
    confettiParticles.push({
      x: w*0.5 + (Math.random()-0.5)*w*0.30,
      y: h*0.25 + (Math.random()-0.5)*h*0.10,
      vx: (Math.random()-0.5) * (big ? 8 : 5) * devicePixelRatio,
      vy: (Math.random()*6 + 4) * devicePixelRatio,
      r: (Math.random()*5 + 3) * devicePixelRatio,
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.25,
      life: 1,
      fade: Math.random()*0.02 + 0.012
    });
  }
}

function tickConfetti(){
  const w = confettiCanvas.width, h = confettiCanvas.height;
  ctx2.clearRect(0,0,w,h);

  confettiParticles.forEach(p=>{
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.14 * devicePixelRatio;
    p.rot += p.vr;
    p.life -= p.fade;

    ctx2.save();
    ctx2.translate(p.x, p.y);
    ctx2.rotate(p.rot);
    ctx2.globalAlpha = clamp(p.life,0,1);
    ctx2.fillStyle = `hsl(${Math.floor(Math.random()*360)}, 90%, 60%)`;
    ctx2.fillRect(-p.r, -p.r*0.5, p.r*2, p.r);
    ctx2.restore();
  });

  confettiParticles = confettiParticles.filter(p=>p.life>0 && p.y < h + 80*devicePixelRatio);
  requestAnimationFrame(tickConfetti);
}
tickConfetti();

/* ============================================================
   Buttons
============================================================ */
el("startBtn").addEventListener("click", ()=>{ beep("click"); startGame(); });
el("resetBtn").addEventListener("click", ()=>{ beep("click"); resetGame(); });
el("muteBtn").addEventListener("click", ()=>{
  state.muted = !state.muted;
  el("muteBtn").textContent = state.muted ? "ðŸ”‡ Muted" : "ðŸ”Š Sound";
  showToast(state.muted ? "Sound off" : "Sound on");
});

/* ============================================================
   Init
============================================================ */
resetGame();
resizeConfettiCanvas();
</script>
</body>
</html>
